原文地址：

 [「查缺补漏」巩固你的HTTP知识体系](https://juejin.cn/post/6857287743966281736)

### **HTTP协议优缺点**

#### 特点

- **灵活可扩展** ，一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。
- **请求-应答模式**
- **可靠传输**，基于TCP/IP
- **无状态**

#### 缺点

- **无状态**
- **明文传输**
- **队头阻塞**

### **HTTP/1.0 HTTP1.1 HTTP2.0版本之间的差异**

#### HTTP 0.9

- 1991,功能简陋，只有一个命令GET,只支持纯文本内容，该版本已过时

#### HTTP 1.0

- 任何格式的内容都可以发送,文字，图像，视频，二进制等文件
- 除了get,引入post，head
- http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据
- 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准
- 不支持断点续传
- 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）

#### HTTP 1.1

- 持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive，长连接的连接时长可以通过请求头中的 `keep-alive` 来设置。
- 引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个 请求
- 新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。
- 支持断点续传，通过使用请求头中的 `Range` 来实现。
- 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
- 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。

#### http1.x版本问题

- 明文传输，无法验证对方的身份，无法保证数据的安全性

- 队头阻塞，HTTP/1.1 版本默认允许复用TCP连接，同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个

- Keep-alive会极大影响性能，http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，因为它在文件被请求之后还保持了不必要的连接很长时间。

####  HTTP 2.0

- `二进制分帧`  这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
- `头部压缩`  HTTP 1.1版本会出现 **「User-Agent、Cookie、Accept、Server、Range」** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 `HPACK` 算法进行压缩。
- `多路复用` 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
- `服务器推送` 允许服务器未经请求，主动向客户端发送资源，即服务器推送。
- `请求优先级` 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。

### **HTTP 常见状态码**

- **「1xx」**: 代表请求已被接受，需要继续处理。
- **「2xx」**: 表示成功状态。
  - 200 OK 表示从客户端发来的请求在服务器端被正确请求
  - 204 No content，表示请求成功，但没有资源可返回。
  - 206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 **「Content-Range」** 指定范围的实体内容。
- **「3xx」**: 重定向状态。
  - 301 永久性重定向
  - 302 临时性重定向
  - 303 表示资源存在着另一个 URL，应使用 GET 方法获取资源
  - 304  协商缓存命中
  - 307 临时重定向，和302含义相同,不会改变method
- **「4xx」**: 客户端错误。
  - 400  bad request   请求报文存在语法错误
  - 401 unauthorized 表示发送的请求需要有通过 HTTP 认证的认证信息
  - 403 forbidden，表示对请求资源的访问被服务器拒绝
  - 404 not found，表示在服务器上没有找到请求的资源。
  - 405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法
- **「5xx」**: 服务器端错误。
  - 500 internal sever error，表示服务器端在执行请求时发生了错误
  - 502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道
  - 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。

### **HTTP 缓存策略**

### 强缓存

- Expires， HTTP1.0
  - 即过期时间，```Expires:Mon, 29 Jun 2020 11:10:23 GMT```
  - 2020年`7月29日11:10:23`过期
- Cache-Control ，HTTP1.1
  - ```Cache-Control:max-age=6000```
  - 资源返回后6000秒，可以直接使用缓存
- 当Expires和Cache-Control同时存在时，优先考虑Cache-Control。
- 当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存

####  协商缓存

- **Last-Modified**
  - 最后修改时间,在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段
  - 浏览器接收到后，**「如果再次请求」**，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间
  - 服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比
    - 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
    - 否则返回304，告诉浏览器直接使用缓存
- **ETag**
  - ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器
  - 浏览器接受到ETag值，会在下次请求的时候，将这个值作为**「If-None-Match」**这个字段的内容，发给服务器
  - 服务器接收到**「If-None-Match」**后，会跟服务器上该资源的**「ETag」**进行比对
    - 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存
    - 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样

- 对比
  - 性能上，Last-Modified`优于`ETag
  - 精度上，ETag`优于`Last-Modified

####  缓存位置

 优先级从高到低排列分别：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache
  - 推送缓存 它是`HTTP/2`的内容

### **HTTP 的请求方法**

- HTTP1.0， GET, POST 和 HEAD方法

- HTTP1.1,

  - GET：                请求获取Request-URI所标识的资源

  - POST：              在Request-URI所标识的资源后附加新的数据

  - HEAD：             请求获取由Request-URI所标识的资源的响应消息报头

  - PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）

  - DELETE：          请求服务器删除对应所标识的资源

  - TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断

  - CONNECT：      建立连接隧道，用于代理服务器

  - OPTIONS：       列出可对资源实行的请求方法，用来跨域请求

### **GET 和 POST 的区别**

- 从缓存角度看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。
- 从参数角度来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。
- 从编码角度看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。
- GET请求幂等，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。
- GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。

###  **options 方法有什么用**

- OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。
- 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。
- JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

###  **队头阻塞问题**

- 对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是`HTTP队头阻塞`问题
- 

###  **HTTP数据传输**

- **定长数据**
  - Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。
  - 如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。
  - 那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。
  - 在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于`Content-Length`,若是非Keep-alive，跟前面情况一样，Content-Length可有可无。
- **不定长数据**
  - Transfer-Encoding: chunked
  - 如果头部信息中有`Transfer-Encoding`,优先采用Transfer-Encoding里面的方法来找到对应的长度。
  - 如果设置了Transfer-Encoding，那么Content-Length将被忽视。
  - 使用长连接的话，会持续的推送动态内容。

### **HTTPS和HTTP**区别

- https = http + TLS/SSL
  - **SSL** 安全套接层（Secure Sockets Layer）
  - **TLS** （传输层安全，Transport Layer Security）
- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全
- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。
- HTTPS标准端口443，HTTP标准端口80
- HTTPS需要用到SSL证书，而HTTP不用

**HTTPS:**

1. 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;
2. 对网站服务器进行真实身份认证。

































